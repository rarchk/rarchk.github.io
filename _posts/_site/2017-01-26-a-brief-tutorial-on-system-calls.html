<p>There exists three ways in which we can talk to kernel</p>

<ul>
  <li>system calls</li>
  <li>traps</li>
  <li>exceptions</li>
</ul>

<p>System calls are kind of macro instructions which a user program asks kernel to execute on its behalf. A system call may be needed to read/write files, open some network sockets or create some child process.</p>

<p>Generally speaking, a user program does not directly invokes system call, but uses a tiny library wrapper which does the following</p>

<ul>
  <li>
    <p>copying arguments and the unique system call number to the registers where the kernel expects them;</p>
  </li>
  <li>
    <p>trapping  to kernel mode, at which point the kernel does the real work of the system call;</p>
  </li>
  <li>
    <p>setting errno if the system call returns an error number when the kernel returns the CPU to user mode.</p>
  </li>
</ul>

<p>Some system calls may not have wrappers defined, so we can use <em>syscall(2)</em> to define a wrapper for them.</p>

<h3 id="control-flow-of-system-calls">Control flow of System Calls</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>---------------------------------------------
H/W Interface __ Kernel Space  __ User Space
 (Resources)	 (System Call)      ( API )
---------------------------------------------
</code></pre>
</div>
<p>###How System Call works ? 
- System call executes in the kernel mode, and every call has a syscall number associated with them. For more information, check out <em>/usr/include/asm/unistd.h</em></p>

<ul>
  <li>
    <p>In Kernel sys_call_table, these numbers are stored. So when a system call is issued, the respective <br />
 number is passed on to the kernel</p>
  </li>
  <li>
    <p>User program issues a system call via issuing a trap to the OS by executing INTerrupt 0x80</p>
  </li>
  <li>
    <p>sys_call_num is passed by pusing value to the EAX register and respective arguments are  passed via 
other registers (EBX, ECX, etc.) Results are returned, using the same registers.</p>
  </li>
</ul>

