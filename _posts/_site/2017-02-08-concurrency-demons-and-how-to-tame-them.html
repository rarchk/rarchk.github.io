<p>In this blog post, I talk in detail about what are different methods to achieve concurrency in more detail. I have worked on golang, python, C and rust. So writing this post will be like writing a story.</p>

<h3 id="traditonal-locks">Traditonal locks</h3>
<p><strong>Balaban in the court</strong>: Strict mandates and orders that needs to be followed if in case conflict happens. Workers carefully adhere to use such parameters because it is balaban court. For eg. <em>semphore, futex ,mutex etc.</em></p>

<h4 id="problem-with-traditonal-locks">Problem with traditonal locks</h4>
<ul>
  <li>locks donâ€™t compose</li>
  <li>locks break encapsulation like rand()</li>
  <li>taking too few/many locks</li>
  <li>taking wrong locks</li>
  <li>taking locks in wrong order</li>
  <li>error recovery is hard</li>
</ul>

<h3 id="atomic-locks">Atomic Locks</h3>
<p><strong>Birbal in the court</strong>: He could intelligently divide the nature of work so that worker gets to independent from get-go. <em>(lockfree and waitless synchronizaiotn)</em></p>

<h2 id="how-go-achieves-concurrency">How Go achieves concurrency</h2>

<table>
  <thead>
    <tr>
      <th>Features</th>
      <th style="text-align: center">Go routines</th>
      <th style="text-align: center">OS Threads</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Communication</td>
      <td style="text-align: center">Go channels</td>
      <td style="text-align: center">Shared Memory</td>
    </tr>
    <tr>
      <td>Scheduling</td>
      <td style="text-align: center">Cooperative</td>
      <td style="text-align: center">OS Scheduling</td>
    </tr>
    <tr>
      <td>Memory</td>
      <td style="text-align: center">Grows and Shrinks Stacks of 2KB Dynamically</td>
      <td style="text-align: center">1MB of thread data structure and have to tear down or built up</td>
    </tr>
    <tr>
      <td>Garbage Collector</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td>Context Switching save/restore</td>
      <td style="text-align: center">PC, SP, DX</td>
      <td style="text-align: center">16 GP, PC, SP, segment, 16 XMM , 16 AVX registers, FP coprocessor state, all MSRs</td>
    </tr>
    <tr>
      <td>Abstraction</td>
      <td style="text-align: center">Built upon threads</td>
      <td style="text-align: center">POSIX</td>
    </tr>
  </tbody>
</table>

<h2 id="many-other-languages-treat-concurrency-in-different-way">Many other languages treat concurrency in different way</h2>
<ul>
  <li>Erlang explicitly does not allow to share state and only communication that can happen is through messages.</li>
  <li>Clojure has immutable ds, which allows it to handle concurrency in log-oriented way.</li>
  <li>Rust has strong checking mechanisms, that at least detect race conditions at compile time.</li>
</ul>
